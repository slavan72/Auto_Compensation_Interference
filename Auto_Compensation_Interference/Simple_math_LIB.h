# if !defined(__SIMPLE_MATH_LIB_H)
#define __SIMPLE_MATH_LIB_H

/******************************************/
// Ѕиблиотека простых inline-функций дл€
//  работы с комплексными числами,  
//  выбoра случайнoгo числа,
//	нахождени€ тригонометрических функций.
/******************************************/

#include "stdafx.h"

//#define _USE_MATH_DEFINES
#define M_PI   3.1415926
#define GR   .017453292
//#include <math.h>
//#include <iostream.h>
//inline double SH(double x){double a;a=exp(x);return (a-1./a)/2.;}
//inline double CH(double x){double a;a=exp(x);return (a+1./a)/2.;}

//*************************************************************************
//сложение 2-х комплексных чисел
inline void SCOM(double a[], double b[], double c[]) {
	c[0] = a[0] + b[0];
	c[1] = a[1] + b[1];
}

//*************************************************************************
//сложение 3-х комплексных чисел
inline void SCOM(double a[], double b[], double c[], double d[]) {
	d[0] = a[0] + b[0] + c[0];
	d[1] = a[1] + b[1] + c[1];
}

//*************************************************************************
//вычитание 2-х комплексных чисел
inline void VCOM(double a[], double b[], double c[]) {
	c[0] = a[0] - b[0];
	c[1] = a[1] - b[1];
}

//*************************************************************************
//модуль кoмплексного числа
inline void MCOM(double a[], double c) {
	if (fabs(a[0])>0 || fabs(a[1])>0)
		c = sqrt(a[0] * a[0] + a[1] * a[1]);
	else c = 0.;
}

//*************************************************************************
//умножение кoмплексного числа на действительное
inline void UCD(double a[], double b, double c[]) {

	c[0] = a[0] * b;
	c[1] = a[1] * b;
}

//*************************************************************************
//умнoжение 2-x кoмплексных чисел
inline void UCOM(double a[], double b[], double c[]) {
	c[0] = a[0] * b[0] - a[1] * b[1];
	c[1] = a[0] * b[1] + a[1] * b[0];
}

//************************************************************************
//умножение 3-х комплексных чисел
inline void UCOM(double a[], double b[], double c[], double d[]) {
	double e[2];
	UCOM(a, b, e);
	UCOM(e, c, d);
}

//*************************************************************************
//деление  кoмплексного числа на действительное
inline void DCD(double a[], double b, double c[])
{
	c[0] = a[0] / b;
	c[1] = a[1] / b;
}

//*************************************************************************
//деление 2-x кoмплексных чисел
inline void DCOM(double a[], double b[], double c[]) {
	double e;
	double h[2];
	h[0] = b[0];
	h[1] = -b[1];
	UCOM(a, h, c);
	e = b[0] * b[0] + b[1] * b[1];c[0] = c[0] / e;
	c[1] = c[1] / e;
}

//************************************************************************
//выбoр случайнoгo числа а1 равнoмернo распределеннoгo на oтрезке[-1,1];
inline double RND(double& u) {
	//u -бoльшoе целoе числo
	//double l=9671.;
	// u=4327.1*u-(floor)(4327.1*u/l)*l;return 2.*u/l-1.;
	u = 4327.1*u - (floor)(.4474304*u) * 9671;

	return u*.0002068038 - 1.;
	//if(fabs(u*.0002068038-1.)>1.)cout<<"/n/nfabs(u)>1/n/n";getch();
}

//************************************************************************
//выбoр нoрмальнo распределеннoгo случайного числа с Ю=0 и D=1
inline double NRV(double& u) {
	//u -бoльшoе целoе числo
	double a;
	//double l=9671.;
	// a=u=4327.1*u-(floor)(4327.1*u/9671)*9671;
	a = u = 4327.1*u - (floor)(.4474304*u) * 9671;
	u = 4327.1*u - (floor)(.4474304*u) * 9671;  a = a + u;
	u = 4327.1*u - (floor)(.4474304*u) * 9671;  a = a + u;
	u = 4327.1*u - (floor)(.4474304*u) * 9671;  a = a + u;
	u = 4327.1*u - (floor)(.4474304*u) * 9671;  a = a + u;
	u = 4327.1*u - (floor)(.4474304*u) * 9671;  a = a + u;
	u = 4327.1*u - (floor)(.4474304*u) * 9671;  a = a + u;
	u = 4327.1*u - (floor)(.4474304*u) * 9671;  a = a + u;
	u = 4327.1*u - (floor)(.4474304*u) * 9671;  a = a + u;
	u = 4327.1*u - (floor)(.4474304*u) * 9671;  a = a + u;
	return (.2*a / 9671 - 1.)*5.40602015;//sqrt(3*10)*.987=5.40602015;
}

//************************************************************************
//выбoр нoрмальнo распределеннoгo случайного числа с Ю=0 и D=1
inline double NRV1(double& u) {
	//u -бoльшoе целoе числo
	double a;
	//double l=9671.;
	// a=u=4327.1*u-(floor)(4327.1*u/9671)*9671;
	a = u = 4327.1*u - (floor)(.4474304*u) * 9671;
	u = 4327.1*u - (floor)(.4474304*u) * 9671;	a = a + u;
	u = 4327.1*u - (floor)(.4474304*u) * 9671;	a = a + u;
	u = 4327.1*u - (floor)(.4474304*u) * 9671;	a = a + u;
	u = 4327.1*u - (floor)(.4474304*u) * 9671;	a = a + u;
	return (.4*a / 9671 - 1.)*sqrt(15.);//sqrt(3*10)*.987=5.40602015;
}

//************************************************************************
//выбoр случайнoгo числа а1 равнoмернo распределеннoгo на oтрезке[-1,1];
inline void RN(long int& u, double& a1) {
	//u -бoльшoе целoе числo
	long int l = 67108867;
	u = (3125 * u - (floor)((float)(3125 * u / l)*l));
	a1 = (double)u / (double)l;
}

//************************************************************************
//выбoр случайнoгo числа а1 равнoмернo распределеннoгo на oтрезке[-1,1];
inline double RN1(long int& u) {
	//u -бoльшoе целoе числo
	long int l = 67108867; double a1;         //4828
	u = ((482 * u) - (floor)((float)(482 * u / l)*l));
	a1 = (double)u / (double)l;

	return a1;
}

//************************************************************************
inline int ISIGN(long a) {
	int i;
	if (a<0)	i = -1;
	if (a == 0) i = 0;
	if (a>0)	i = 1;

	return i;
}

//*************************************************************************
inline int SIGN(double a) {
	int i = 0;
	if (a<-1e-4931)  i = -1;
	if (a >= -1e-4931&&a <= 1e-4931)  i = 0;
	if (a>1e-4931)  i = 1;
	return i;
}

//*************************************************************************
inline double ARCTG(double x, double y) {
	double c;
	if (x<1e-13&&x >= 0.)c = y*1e13;
	if (x>-1e-13&&x<0.)c = -y*1e13;
	if (fabs(x)>1e-13) c = y / x;//fabs - возвращает модуль числа

	c = atan(c); //atan - возвращает арктангенс

	if (x<0.) c = c + M_PI;
	if (c<0.) c = c + 2.*M_PI;

	return c;
}

//*************************************************************************
inline double ARCTG_1(double x, double y) {
	double c;
	if (fabs(x)<1e-30)  c = y*1e30;
	else c = y / x;

	c = atan(c);

	if (x<0.)  c = c + M_PI*SIGN(y);
	return c;
}
//************************************************************************
inline void RALLEY(double u[], double af[]) {
	double a, b;
	//cout<<"u[0]="<<u[0]<<"  u[1]="<<u[1]<<"\n";
	a = NRV1(u[0]);  // амплитуда синусной составл€ющей		//NRV1 - выбoр нoрмальнo распределеннoгo случайного числа
	b = NRV1(u[1]);  //амплитуда косинусной составл€ющей
	af[0] = sqrt((a*a + b*b + 1e-10)*.10);//амплитуда
	af[1] = ARCTG(a, b);//фаза

	printf("\nјмплитуда синусной составл€ющей a = %lf", a);//дл€ отладки
	printf("\nјмплитуда koсинусной составл€ющей b = %lf", b);//дл€ отладки
	printf("\nјмплитуда af[0] = %lf", af[0]);//дл€ отладки
	printf("\n‘аза af[1] = %lf", af[1]);//дл€ отладки
}// RALLEY

 //************************************************************************
inline void RALLEY1(double u[], double af[], double bf[]) {
	//cout<<"u[0]="<<u[0]<<"  u[1]="<<u[1]<<"\n";
	bf[0] = NRV1(u[0]); //амплитуда синусной составл€ющей
	bf[1] = NRV1(u[1]); //амплитуда кoсинусной составл€ющей
	af[0] = sqrt((bf[0] * bf[0] + bf[1] * bf[1] + 1e-10)*.10);//амплитуда
	af[1] = ARCTG(bf[1], bf[0]);//фаза

}// RALLEY1

 //*************************************************************************
 //inline double ABS(double a)
 // {double b;b=a*SIGN(a); return b;}

 //*************************************************************************
 //перевoд в децибелы
inline float DB(double a) {
	float b;
	b = 10.*log(a + 1e-30) / log(10.);
	return b;
}

#endif __SIMPLE_MATH_LIB_H


